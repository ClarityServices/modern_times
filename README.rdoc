= modern_times

* http://github.com/ClarityServices/modern_times

== Description:

JRuby library for performing background tasks via JMS.

Very much alpha stage at this point.

== Features/Problems:

* Topics don't work
* Ruby marshaling doesn't work
* jms_test doesn't exit
* jms_requestor needs testing

== Install:

  gem install modern_times

== Rails Usage:

Create config/jms.yml which might look as follows:

    development:
      :connection: hornetq://invm

    production:
      :connection:
        :uri: hornetq://msg1,msg2
        :failover_on_initial_connection: true
        :failover_on_server_shutdown: true
        # 5 Connection attempts takes about 16 seconds before it switches to the backup server
        :reconnect_attempts: 5
      :session:
        :username: mycluster_username
        :password: mycluster_password

In config/environment.rb, add the following lines:

    ModernTimes.init_rails
    # Publishers can be defined wherever appropriate
    $foo_publisher = ModernTimes::HornetQ::Publisher.new('Foo')

In your code, queue foo objects:

    $foo_publisher.publish(my_foo_object)

In app/workers, create a FooWorker class:

    class FooWorker < ModernTimes::HornetQ::Worker
      def perform(my_foo_object)
        # Operate on my_foo_object
      end
    end

Based on the hornetq.yml file above, a development mode connection will be created such that
the queueing is handled in-memory (since the uri is 'hornetq://invm').
When this is used, a single thread (by default) will be created for each defined Worker so queued
messages will be handled asynchronously within the same process.

In test mode, there is no configuration defined.  In this case, published messages will cause
synchronous calls to the Worker's perform method.

In production mode, you will need to start up a hornetq server to distribute the messages.  For the
configuration above, you might create a hornetq_server.yml file as follows:

    # backup server runs on msg2
    backup_server:
      :uri:                 hornetq://0.0.0.0
      :backup:              true
      :data_directory:      /var/lib/hornetq/data
      :persistence_enabled: true
      :security_enabled:    true
      :cluster_user:        mycluster_username
      :cluster_password:    mycluster_password

    # live server runs on msg1
    live_server:
      :uri:                 hornetq://0.0.0.0,msg2
      :data_directory:      /var/lib/hornetq/data
      :persistence_enabled: true
      :security_enabled:    true
      :cluster_user:        mycluster_username
      :cluster_password:    mycluster_password

Then on host msg2 and msg1, you could startup the servers with the following commands:

    # On msg2
    hornetq_server hornetq_server.yml backup_server
    # On msg1
    hornetq_server hornetq_server.yml live_server

For the production environment, you will need to startup a Manager process to handle messages.  You
might create script/worker_manager as follows (assumes Rails.root/script is in your PATH):

    #!/usr/bin/env runner

    manager = ModernTimes.create_rails_manager
    manager.join

TODO:  Refer to example jsvc daemon script

Configure your workers by starting jconsole and connecting to
the manager process.  Go to the MBeans tab and open the tree to
ModernTimes => Manager => Operations => start_worker

Start/stop/increase/decrease workers as needed.  The state is stored in the log directory (by default)
so you can stop and start the manager and not have to reconfigure your workers.
TODO:  This is flaky right now due to bugs in jruby-jmx.

== Multiple Workers For a Single Address:

By default, a worker operates on the address and queue with the same name as the class.  You can override
this by explicitily stating the address and queue that the worker should operate on.  For instance, the
Fooworker defined above is equivalent to the following:

    class FooWorker < ModernTimes::HornetQ::Worker
      address 'Foo'
      queue   'Foo'
      def perform(my_foo_object)
        # Operate on my_foo_object
      end
    end

You can setup multiple workers to operate on the same address.  For instance, the following worker would
create a separate queue that would also receive all the messages published on address 'Foo':

    class BarWorker < ModernTimes::HornetQ::Worker
      address 'Foo'
      def perform(my_foo_object)
        # Operate on my_foo_object
      end
    end


== What's with the name?

I'm a Chaplin fan.

== Author

Brad Pardee, Reid Morrison

== Copyright

Copyright (c) 2011 Clarity Services. See LICENSE for details.
